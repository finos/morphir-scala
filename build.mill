//| mvnDeps:
//| - com.lihaoyi::mill-contrib-buildinfo:$MILL_VERSION
//| - com.lihaoyi::mill-contrib-scoverage:$MILL_VERSION
//| - com.carlosedp::mill-aliases::1.1.0
//| - com.github.lolgab::mill-mima::0.2.0
//| - dev.zio::zio:2.1.5
//| - dev.zio::zio-config:4.0.3
//| - dev.zio::zio-config-magnolia:4.0.3
//| - dev.zio::zio-config-typesafe:4.0.3
//| - dev.zio::zio-config-yaml:4.0.0-RC16
//| - dev.zio::zio-config-refined:4.0.3

package build

import millbuild.{Deps, MillVersions, Versions => Vers, ScalaVersions => ScalaVers}
import millbuild.docs.{Docusaurus2Module, MDocModule}
import mill.scalalib.publish.PublishInfo
import mill.local.plugins.ci.release.ReleaseSetupModule
import com.carlosedp.aliases.*
import millbuild.*
import millbuild.crossplatform.*
import millbuild.jsruntime.*
import org.finos.millmorphir.*
import org.finos.millmorphir.elm.*
import millbuild.settings.*
import mill.*, mill.scalalib.*, mill.scalajslib.*, mill.scalanativelib.*, scalafmt.*
import mill.scalajslib.api.ModuleKind
import mill.contrib.buildinfo.BuildInfo
import mill.contrib.scoverage.{ScoverageModule, ScoverageReport}
import com.github.lolgab.mill.mima.*
import mill.util.VcsVersion
import scala.concurrent.duration.DurationInt

implicit val buildSettings: BuildSettings = MyBuild.cachedBuildSettings

def resolvedBuildSettings: T[BuildSettings] = Task { MyBuild.buildSettings() }

/**
 * The version of Scala natively supported by the toolchain. Morphir itself may provide backends that generate code for
 * other Scala versions. We may also directly cross-compile to additional Scla versions.
 */
val morphirScalaVersion: String = buildSettings.scala.defaultVersion

val docsScalaVersion: String =
  buildSettings.scala.scala213Version // This really should match but need to figure it out

// Get workspace dir from the build context
val workspaceDir = mill.api.BuildCtx.workspaceRoot

def showBuildSettings() = Task.Command {
  val settings = MyBuild.buildSettings()
  pprint.pprintln(settings)
  ()
}

object scoverage extends ScoverageReport {
  // While the plugin doesn't seem to support multiple scala versions, that doesn't seem to impact the coverage
  // For overall coverage report, just specifying Scala 3
  def scalaVersion     = ScalaVers.scala3x
  def scoverageVersion = Vers.scoverage
}

trait MorphirPublishModule extends PublishModule with JavaModule with Mima {
  import mill.scalalib.publish.*

  def publishVersion             = VcsVersion.vcsState().format()
  def packageDescription: String = s"The $artifactName package"
  def pomSettings = PomSettings(
    description = packageDescription,
    organization = "org.finos.morphir",
    url = "https://github.com/finos/morphir-scala",
    licenses = Seq(License.`Apache-2.0`),
    versionControl = VersionControl.github("finos", "morphir-scala"),
    developers = Seq(
      Developer("DamianReeves", "Damian Reeves", "https://github.com/damianreeves")
    )
  )
}

object morphir extends Cross[MorphirCrossModule](buildSettings.scala.crossScalaVersions) {
  object build extends Module {
    object integration extends Module {
      object `mill-morphir-elm` extends Cross[morphirlibElmPlugin](MillVersions.all)
      trait morphirlibElmPlugin
          extends Cross.Module[String]
          with ScalaModule
          with ScalafmtModule
          with MorphirPublishModule {

        def millVersion = crossValue

        val pluginName = "mill-morphir-elm"

        def scalaVersion          = Task { resolvedBuildSettings().mill.scalaVersion }
        override def artifactName = s"${pluginName}_mill${MillVersions.millBinaryVersion(millVersion)}"
        override def compileMvnDeps = super.compileMvnDeps() ++ Seq(
          ivy"com.lihaoyi::mill-scalalib:${millVersion}"
        )
        override def scalacOptions = Seq("-Ywarn-unused", "-deprecation")
        override def sources = Task {
          super.sources() ++ Seq(
            PathRef(moduleDir / s"src-mill${millVersion.split('.').take(2).mkString(".")}")
          )
        }
      }
    }
  }

  object main extends CommonScalaModule with MorphirPublishModule with BuildInfo {

    def buildInfoPackageName = "org.finos.morphir.cli"

    def buildInfoMembers = Seq(
      BuildInfo.Value("version", publishVersion()),
      BuildInfo.Value("scalaVersion", scalaVersion())
    )

    override def extraPublish: T[Seq[PublishInfo]] = Task {
      Seq(PublishInfo(file = assembly(), classifier = Some("assembly"), ivyConfig = "compile"))
    }

    val mainScalaVersion = morphirScalaVersion

    def packageDescription =
      "The morphir-main package. This is the main entry point for the morphir tooling, including the morphir-cli."

    def scalaVersion = Task { mainScalaVersion }
    def mvnDeps = Seq(
      Deps.co.fs2.`fs2-io`,
      Deps.com.lihaoyi.fansi,
      Deps.com.lihaoyi.pprint,
      Deps.com.lihaoyi.sourcecode,
      Deps.dev.zio.zio,
      Deps.dev.zio.`zio-interop-cats`,
      Deps.dev.zio.`zio-cli`,
      Deps.dev.zio.`zio-config`,
      Deps.dev.zio.config.magnolia,
      Deps.dev.zio.config.refined,
      Deps.dev.zio.config.typesafe
    )

    def moduleDeps =
      Seq(
        morphir(mainScalaVersion).jvm,
        morphir(mainScalaVersion).runtime.jvm,
        morphir(mainScalaVersion).tools.jvm
      )
  }

}
trait MorphirCrossModule extends Cross.Module[String] with CrossPlatform { morphir =>
  import DevMode._

  trait MorphirCommonModule extends ScalaModule with CrossValue with CommonScalaModule {
    def semanticDbVersion: T[String] = Task { Vers.semanticDb(partialVersion()) }

    def compilerPluginDependencies(selectedScalaVersion: String) =
      if (selectedScalaVersion.startsWith("3.")) {
        Seq(Deps.org.`scala-lang`.`scala3-compiler`(selectedScalaVersion))
      } else Seq.empty[Dep]
  }

  trait DeduplicatedSources extends ScalaModule {
    override def sources: T[Seq[PathRef]] = Task {
      super.sources().distinctBy(_.path)
    }
  }

  trait MorphirCommonCrossModule extends CrossPlatformScalaModule with CrossValue with CommonCrossScalaModule with DeduplicatedSources {
    def semanticDbVersion: T[String] = Task { Vers.semanticDb(partialVersion()) }
    def compilerPluginDependencies(selectedScalaVersion: String) =
      if (selectedScalaVersion.startsWith("3.")) {
        Seq(Deps.org.`scala-lang`.`scala3-compiler`(selectedScalaVersion))
      } else Seq.empty[Dep]
  }

  trait MorphirJVMModule extends MorphirCommonCrossModule {
    def platform = Platform.JVM
  }

  trait MorphirJSModule extends MorphirCommonCrossModule with ScalaJSModule {
    import mill.scalajslib.api.*
    def platform       = Platform.JS
    def scalaJSVersion = Task { resolvedBuildSettings().js.version }
  }

  trait MorphirNativeModule extends MorphirCommonCrossModule {
    def platform           = Platform.Native
    def scalaNativeVersion = Task { resolvedBuildSettings().native.version }
  }

  trait Shared extends MorphirCommonCrossModule with MorphirPublishModule {
    def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.org.`scala-lang`.modules.`scala-collection-contrib`,
      Deps.com.beachape.enumeratum,
      Deps.com.lihaoyi.fansi,
      Deps.com.lihaoyi.geny,
      Deps.com.lihaoyi.sourcecode,
      Deps.com.lihaoyi.pprint,
      Deps.dev.zio.`izumi-reflect`,
      Deps.dev.zio.zio,
      Deps.dev.zio.`zio-json`,
      Deps.dev.zio.`zio-prelude`,
      Deps.org.typelevel.spire
    ) ++ (if (isScala3()) Seq(Deps.com.softwaremill.magnolia_3.magnolia) else Seq.empty[Dep]) ++
      (if (isScala2()) Seq(Deps.com.softwaremill.magnolia_2.magnolia) else Seq.empty[Dep])

    def compileMvnDeps = super.compileMvnDeps() ++ (if (crossScalaVersion.startsWith("2."))
                                                      Seq(
                                                        Deps.org.`scala-lang`.`scala-reflect`(crossScalaVersion),
                                                        Deps.org.`scala-lang`.`scala-compiler`(crossScalaVersion)
                                                      )
                                                    else Seq.empty)

    def scalacOptions = Task {
      // val additionalOptions = if (crossScalaVersion.startsWith("2.13")) Seq("-Ymacro-annotations") else Seq.empty
      val additionalOptions =
        if (crossScalaVersion.startsWith("2.13")) Seq("-language:experimental.macros") else Seq.empty
      super.scalacOptions() ++ additionalOptions
    }

    def platformSpecificModuleDeps = Seq(extensibility)
  }

  object jvm extends Shared with MorphirJVMModule
  object js  extends Shared with MorphirJSModule

  object contrib extends Module {
    object knowledge extends CrossPlatform with CrossValue {
      def enableNative(module: Module): Boolean = crossValue.startsWith("2.13.") && !devMode
      trait Shared extends MorphirCommonCrossModule with MorphirPublishModule {
        def mvnDeps = Seq(
          Deps.com.lihaoyi.sourcecode,
          Deps.dev.zio.`zio-streams`
        )
        def platformSpecificModuleDeps = Seq(morphir)
      }

      object jvm extends Shared with MorphirJVMModule with ScoverageModule {
        def scoverageVersion = Vers.scoverage

        object test extends ScoverageTests with TestModule.ZioTest {
          def mvnDeps = Seq(
            Deps.dev.zio.zio,
            Deps.dev.zio.`zio-streams`,
            Deps.dev.zio.`zio-test`,
            Deps.dev.zio.`zio-test-sbt`
          )
          def moduleDeps = super.moduleDeps ++ Seq(testing.zio.jvm)
        }
      }

      object js extends Shared with MorphirJSModule {
        object test extends ScalaJSTests with TestModule.ZioTest {
          def mvnDeps = Seq(
            Deps.dev.zio.zio,
            Deps.dev.zio.`zio-streams`,
            Deps.dev.zio.`zio-test`,
            Deps.dev.zio.`zio-test-sbt`
          )
          def moduleDeps = super.moduleDeps ++ Seq(testing.zio.js)
        }
      }
    }
  }

  object extensibility extends CrossPlatform with CrossValue {

    trait Shared extends MorphirCommonCrossModule with MorphirPublishModule with BuildInfo {

      def buildInfoPackageName = "org.finos.morphir.extensibility"

      def buildInfoMembers = Seq(
        BuildInfo.Value("version", publishVersion()),
        BuildInfo.Value("scalaVersion", scalaVersion()),
        BuildInfo.Value("platform", platform.toString)
      )
    }

    object jvm extends Shared with MorphirJVMModule
    object js  extends Shared with MorphirJSModule
  }

  object interop extends Module {
    object zio extends Module {
      object json extends CrossPlatform with CrossValue {
        trait Shared extends MorphirCommonCrossModule with MorphirPublishModule {
          def mvnDeps                    = Seq(Deps.dev.zio.`zio-json`)
          def platformSpecificModuleDeps = Seq(morphir)
        }

        object jvm extends Shared with MorphirJVMModule with ScoverageModule {
          def scoverageVersion = Vers.scoverage

          object test extends ScoverageTests with TestModule.ZioTest {
            def mvnDeps: T[Seq[Dep]] = Task {
              Seq(
                Deps.dev.zio.`zio-json-golden`,
                mvn"io.github.deblockt:json-diff:1.1.0",
                mvn"com.fasterxml.jackson.core:jackson-databind:2.18.3",
                Deps.dev.zio.`zio-process`
              )
            }

            def moduleDeps = super.moduleDeps ++ Seq(morphir.testing.generators.jvm, testing.zio.jvm)
          }
        }

        object js extends Shared with MorphirJSModule
      }
    }

    object borer extends CrossPlatform with CrossValue {
      trait Shared extends MorphirCommonCrossModule with MorphirPublishModule {
        def mvnDeps = Seq(
          Deps.io.bullet.`borer-core`(crossScalaVersion),
          Deps.io.bullet.`borer-derivation`(crossScalaVersion)
        )

        def platformSpecificModuleDeps = Seq(morphir)
      }

      object jvm extends Shared with MorphirJVMModule with ScoverageModule {
        def scoverageVersion = Vers.scoverage

        object test extends ScoverageTests with TestModule.ZioTest {
          def mvnDeps: T[Seq[Dep]] = Task {
            Seq(
              Deps.io.bullet.`borer-core`(crossScalaVersion),
              Deps.io.bullet.`borer-derivation`(crossScalaVersion)
            )
          }

          def moduleDeps = super.moduleDeps ++ Seq(morphir.testing.generators.jvm, testing.zio.jvm)
        }
      }

      object js extends Shared with MorphirJSModule
    }
  }
  object lib extends Module {

    object interop extends CrossPlatform {
      trait Shared extends MorphirCommonCrossModule with MorphirPublishModule {}
      object jvm   extends Shared with MorphirJVMModule
      object js    extends Shared with MorphirJSModule
    }
  }

  object runtime extends CrossPlatform with CrossValue {

    def enableNative(module: Module): Boolean = crossValue.startsWith("2.13.") && !devMode
    trait Shared extends MorphirCommonCrossModule with MorphirPublishModule {
      def platformSpecificModuleDeps = Seq(morphir, morphir.interop.zio.json)
    }

    trait RuntimeTests extends TestModule.ZioTest {
      def morphirTestSources = Task {
        examples.`morphir-elm-projects`.`evaluator-tests`.distOutputDirs()
      }

      def morphirTestSourceFiles = Task {
        Lib.findSourceFiles(morphirTestSources(), Seq("json")).collect {
          case path if path.last.startsWith("morphir-") => PathRef(path)
        }
      }
    }

    object jvm extends Shared with MorphirJVMModule with ScoverageModule {
      def scoverageVersion = Vers.scoverage
      // scalac-compat-annotation is JVM-only (no Scala.js artifact available)
      override def mvnDeps = super.mvnDeps() ++ Seq(Deps.org.typelevel.`scalac-compat-annotation`)

      object test extends ScoverageTests with RuntimeTests {
        def mvnDeps = Seq(
          Deps.com.lihaoyi.`os-lib`,
          Deps.com.lihaoyi.sourcecode,
          Deps.dev.zio.`zio-test`,
          Deps.dev.zio.`zio-test-sbt`
        )
        def moduleDeps = super.moduleDeps ++ Seq(testing.zio.jvm)
      }
    }

    object js extends Shared with MorphirJSModule {
      object test extends ScalaJSTests with RuntimeTests {
        def mvnDeps    = Seq(Deps.dev.zio.`zio-test`, Deps.dev.zio.`zio-test-sbt`)
        def moduleDeps = super.moduleDeps ++ Seq(testing.zio.js)
        def moduleKind = ModuleKind.CommonJSModule
      }
    }
  }

  object testing extends Module {
    object generators extends CrossPlatform with CrossValue {
      trait Shared extends MorphirCommonCrossModule {
        def mvnDeps = Seq(Deps.dev.zio.`zio-test`) ++ (if (!platform.isNative) Seq(Deps.dev.zio.`zio-test-magnolia`) else Seq.empty[Dep])
        def platformSpecificModuleDeps = Seq(morphir)

      }
      object jvm extends Shared with MorphirJVMModule
      object js  extends Shared with MorphirJSModule
    }

    object zio extends CrossPlatform {
      trait Shared extends MorphirCommonCrossModule {
        def mvnDeps = Seq(
          ivy"io.github.cquiroz::scala-java-time::2.6.0",
          Deps.dev.zio.`zio-json`,
          Deps.dev.zio.`zio-prelude`,
          Deps.dev.zio.`zio-test`,
          Deps.dev.zio.`zio-test-sbt`
        )
      }
      object jvm extends Shared with MorphirJVMModule
      object js  extends Shared with MorphirJSModule
    }
  }

  object tests extends CrossPlatform {

    trait Shared extends MorphirCommonCrossModule with MorphirPublishModule {
      def mvnDeps = super.mvnDeps() ++ Seq(
        Deps.com.lihaoyi.sourcecode,
        Deps.io.github.cquiroz.`scala-java-time`,
        Deps.io.github.cquiroz.`scala-java-time-tzdb`
      )
      def platformSpecificModuleDeps = Seq(extensibility, morphir, runtime, tools)
    }

    object jvm extends Shared with MorphirJVMModule with ScoverageModule {
      def scoverageVersion = Vers.scoverage

      object test extends ScoverageTests with TestModule.ZioTest {
        // Use cross-platform sources for test modules too
        def crossPlatformTestSourcePaths: Seq[os.Path] = {
          val basePath = moduleDir
          val platformSuffixes = Seq("jvm", "jvm-native", "js-jvm")
          val versionSuffixes = Seq("", "-3.7.4", "-3.7", "-3")

          // Base sources
          val baseSources = versionSuffixes.map(v => basePath / s"src$v")
          // Platform-specific sources using nesting
          val platformSources = platformSuffixes.flatMap { p =>
            versionSuffixes.map(v => basePath / p / s"src$v")
          }
          (baseSources ++ platformSources).distinct
        }

        override def sources: T[Seq[PathRef]] = Task.Sources(crossPlatformTestSourcePaths*)

        def mvnDeps = Seq(
          Deps.com.lihaoyi.`os-lib`,
          Deps.com.lihaoyi.sourcecode,
          Deps.dev.zio.`zio-test`,
          Deps.dev.zio.`zio-test-sbt`
        )

        def moduleDeps = super.moduleDeps ++ Seq(testing.generators.jvm, testing.zio.jvm)
      }
    }

    object js extends Shared with MorphirJSModule {
      object test extends ScalaJSTests with TestModule.ZioTest {
        // Use cross-platform sources for JS test modules too
        def crossPlatformTestSourcePaths: Seq[os.Path] = {
          val basePath = moduleDir
          // JS platform: include js-specific and js-jvm shared sources (NOT jvm-native)
          val platformSuffixes = Seq("js", "js-jvm")
          val versionSuffixes = Seq("", "-3.7.4", "-3.7", "-3")

          // Base sources
          val baseSources = versionSuffixes.map(v => basePath / s"src$v")
          // Platform-specific sources using nesting
          val platformSources = platformSuffixes.flatMap { p =>
            versionSuffixes.map(v => basePath / p / s"src$v")
          }
          (baseSources ++ platformSources).distinct
        }

        override def sources: T[Seq[PathRef]] = Task.Sources(crossPlatformTestSourcePaths*)

        def mvnDeps    = Seq(Deps.dev.zio.`zio-test`, Deps.dev.zio.`zio-test-sbt`)
        def moduleDeps = super.moduleDeps ++ Seq(testing.generators.js, testing.zio.js)
      }
    }
  }

  object tools extends CrossPlatform {
    trait Shared extends MorphirCommonCrossModule with MorphirPublishModule {
      def mvnDeps = Seq(
        Deps.co.fs2.`fs2-io`,
        Deps.com.lihaoyi.sourcecode,
        Deps.dev.zio.zio,
        Deps.dev.zio.`zio-prelude`,
        Deps.dev.zio.`zio-streams`,
        Deps.com.lihaoyi.pprint,
        Deps.org.typelevel.cats.core,
        Deps.org.typelevel.spire,
        Deps.org.typelevel.`paiges-core`
      ) ++ (if (!platform.isNative) Seq(Deps.dev.zio.`zio-interop-cats`) else Seq.empty[Dep])

      def platformSpecificModuleDeps = Seq(morphir, morphir.interop.zio.json)
    }

    object jvm extends Shared with MorphirJVMModule {
      def mvnDeps = super.mvnDeps() ++ Seq(
        Deps.dev.zio.`zio-nio`,
        Deps.dev.zio.`zio-process`
      )
    }
    object js extends Shared with MorphirJSModule {
      def docSources = Task {
        Lib.findSourceFiles(super.docSources(), Seq("tasty"))
          .map(PathRef(_))
        // .filterNot(_.path.last.contains("ProcessIOPlat"))
      }
    }
  }
}

// The following modules are morphir-elm modules that have been setup to be built using mill
// Morphir Elm Projects/Modules:
object examples extends Module {
  object `morphir-elm-projects` extends Module {
    object finance extends MorphirElmModule

    object `evaluator-tests` extends MorphirElmModule
    object `unit-test-framework` extends Module {
      object `example-project` extends MorphirElmModule {
        def morphirModuleDeps = Seq(`morphir-elm`.sdks.`morphir-unit-test`)
      }

      object `example-project-tests` extends MorphirElmModule {
        def morphirModuleDeps = Seq(
          `morphir-elm`.sdks.`morphir-unit-test`,
          `example-project`
        )
      }
      object `example-project-tests-incomplete` extends MorphirElmModule {
        def morphirModuleDeps = Seq(
          `morphir-elm`.sdks.`morphir-unit-test`,
          `example-project`
        )
      }
      object `example-project-tests-passing` extends MorphirElmModule {
        def morphirModuleDeps = Seq(
          `morphir-elm`.sdks.`morphir-unit-test`,
          `example-project`
        )
      }
    }
  }
}

object `morphir-elm` extends Module {
  object sdks extends Module {
    object `morphir-unit-test` extends MorphirElmModule
  }
}

object ci extends Module {

  def publishSonatype0(
      data: Seq[PublishModule.PublishData],
      log: mill.api.Logger
  ): Unit = {

    val credentials = sys.env("SONATYPE_USERNAME") + ":" + sys.env("SONATYPE_PASSWORD")
    val pgpPassword = sys.env("PGP_PASSPHRASE")
    val timeout     = 20.minutes // SONATYPE CAN BE SUPER SLOW

    val artifacts = data.map {
      case PublishModule.PublishData(a, s) =>
        (s.map { case (p, f) => (p.path, f) }, a)
    }

    val isRelease = {
      val versions = artifacts.map(_._2.version).toSet
      val set      = versions.map(!_.endsWith("-SNAPSHOT"))
      assert(
        set.size == 1,
        s"Found both snapshot and non-snapshot versions: ${versions.toVector.sorted.mkString(", ")}"
      )
      set.head
    }
    val publisher = new scalalib.publish.SonatypePublisher(
      uri = "https://s01.oss.sonatype.org/service/local",
      snapshotUri = "https://s01.oss.sonatype.org/content/repositories/snapshots",
      credentials = credentials,
      signed = true,
      // format: off
      gpgArgs = Seq(
        "--detach-sign",
        "--batch=true",
        "--yes",
        "--pinentry-mode", "loopback",
        "--passphrase", pgpPassword,
        "--armor",
        "--use-agent"
      ),
      // format: on
      readTimeout = timeout.toMillis.toInt,
      connectTimeout = timeout.toMillis.toInt,
      log = log,
      workspace = workspaceDir,
      env = sys.env.toMap,
      awaitTimeout = timeout.toMillis.toInt,
      stagingRelease = isRelease
    )

    publisher.publishAll(isRelease, artifacts*)
  }

}

// The following section contains aliases used to simplify build tasks

object MyAliases extends Aliases {
  def fmt           = alias("mill.scalalib.scalafmt.ScalafmtModule/reformatAll __.sources")
  def checkfmt      = alias("mill.scalalib.scalafmt.ScalafmtModule/checkFormatAll __.sources")
  def deps          = alias("mill.scalalib.Dependency/showUpdates")
  def testall       = alias("__.test")
  def testJVM       = alias("morphir.__.jvm.__.test")
  def testJVMCached = alias("morphir.__.jvm.__.testCached")
  def compileall    = alias("__.compile")
  def comptestall   = alias("__.compile", "__.test")
}
